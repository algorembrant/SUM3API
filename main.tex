%% SUM3API Research Paper
%% Author: Albeos Rembrant
%% LaTeX Document - IEEE Conference Format

\documentclass[conference]{IEEEtran}
\IEEEoverridecommandlockouts

% Packages
\usepackage{cite}
\usepackage{amsmath,amssymb,amsfonts}
\usepackage{algorithmic}
\usepackage{graphicx}
\usepackage{textcomp}
\usepackage{xcolor}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{array}
\usepackage{float}

\usepackage{xcolor}
\usepackage{hyperref}


% Code listing settings
\lstset{
    basicstyle=\ttfamily\footnotesize,
    breaklines=true,
    frame=single,
    numbers=left,
    numberstyle=\tiny,
    tabsize=2,
    captionpos=b
}

% Hyperref settingsA
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    citecolor=blue,
    urlcolor=blue
}

\def\BibTeX{{\rm B\kern-.05em{\sc i\kern-.025em b}\kern-.08em
    T\kern-.1667em\lower.7ex\hbox{E}\kern-.125emX}}

\begin{document}

\title{SUM3API: Using Rust, ZeroMQ, and MetaQuotes Language (MQL5) API Combination to Extract, Communicate, and Externally Project Financial Data from MetaTrader 5 (MT5)}

\author{
    \IEEEauthorblockN{Rembrant Oyangoren Albeos}
    \IEEEauthorblockA{
        \textit{Independent Researcher} \\
        ORCID: https://orcid.org/0009-0006-8743-4419\\
        Email: algorembrant@gmail.com \\
        GitHub: https://github.com/algorembrant/SUM3API\\
        First version: Jan 20, this version Jan 27 2026
    }
}

\maketitle

%% ============================================================================
%% ABSTRACT
%% ============================================================================

\begin{figure}[H]
    \centering
    \includegraphics[width=.70\linewidth]{image.png}
    \caption{SUM3API System Framework}
    \label{fig:placeholder}
\end{figure}

\begin{abstract}
MetaTrader 5 (MT5), when connected to preferred exchanges or brokers, supports automated algorithmic trading via Expert Advisors (EAs) written in MetaQuotes Language (MQL5). While MetaQuotes LLC provides an official Python integration package, publicly documented methods for internally extracting and externally projecting MT5 financial data remain limited. To address this gap, this study implements a novel approach that bridges MQL5 and Rust via ZeroMQ publisher--subscriber and request--reply bindings. This benchmark-based methodology enables quantitative researchers, feature engineers, and algorithmic traders to develop trading systems leveraging MT5 data feeds using Rust, thereby bypassing the limitations inherent to pure MQL5 Expert Advisors. The methodology is validated through integration within a functional trading terminal application demonstrating low-latency capabilities including: real-time account information monitoring (balance, equity, free and used margin), downloadable historical data requests (OHLC bars and raw tick data), downloadable forward data streaming (live tick recording), trade execution controls (market, limit, and stop orders with lot sizing and cancellation), messaging and notifications for debugging \& recent calls, and a live microsecond-resolution raw tick-level bid/ask price formation chart. All resources are open-source and available on GitHub: \url{https://github.com/algorembrant/SUM3API}.
\end{abstract}

\begin{IEEEkeywords}
MetaTrader 5, ZeroMQ, Rust, MetaQuotes Language 5, algorithmic trading, inter-process communication, financial data extraction, low-latency systems
\end{IEEEkeywords}

%% ============================================================================
%% INTRODUCTION
%% ============================================================================

\section{Introduction}

\subsection{Background}

Algorithmic trading has fundamentally transformed financial markets, with automated systems now accounting for a substantial portion of trading volume across global exchanges \cite{hendershott2011}. The MetaTrader 5 (MT5) platform, developed by MetaQuotes Software Corp., has emerged as one of the most widely adopted retail trading platforms, supporting multi-asset trading including forex, stocks, and futures markets \cite{metaquotes2024}. MT5 provides native support for algorithmic trading through Expert Advisors (EAs)---automated trading programs written in MetaQuotes Language 5 (MQL5), a C++-like domain-specific language designed for trading system development.

While MQL5 offers comprehensive functionality for developing trading strategies within the MT5 ecosystem, practitioners frequently encounter limitations when attempting to integrate external tools, leverage modern programming languages, or connect MT5 data streams with external analytical systems. The official MetaTrader 5 Python integration package addresses some of these concerns but remains constrained by platform-specific limitations and lacks support for high-performance, memory-safe languages such as Rust \cite{metaquotes_python2024}.

\subsection{Problem Statement}

Despite the widespread adoption of MetaTrader 5, there exists a notable gap in publicly documented methodologies for extracting financial data from MT5 and projecting it to external applications in real-time. Existing approaches typically fall into three categories: (1) native MQL5 development confined within the MT5 environment, (2) Python-based extraction using the official MetaTrader package with inherent performance limitations, and (3) informal, undocumented workarounds that lack reproducibility and standardization. This gap is particularly problematic for quantitative researchers and algorithmic traders who require access to MT5 data feeds within high-performance computing environments, machine learning pipelines, or custom trading terminals developed in systems programming languages.

\subsection{Research Questions}

This study addresses the following research questions:

\begin{enumerate}
    \item How can bidirectional real-time communication be established between MetaTrader 5 and external applications developed in Rust?
    \item What messaging architecture enables low-latency tick-level data streaming from MT5 to external consumers?
    \item Can a demonstration trading terminal validate the practical applicability of the proposed integration methodology?
\end{enumerate}

\subsection{Objectives}

The primary objectives of this research are:

\begin{enumerate}
    \item To design and implement a ZeroMQ-based communication bridge between MQL5 and Rust
    \item To develop a reusable MQL5 wrapper library for ZeroMQ socket operations
    \item To create a functional Rust-based trading terminal demonstrating real-time data consumption and order execution
    \item To document the methodology with sufficient detail for reproducibility
\end{enumerate}

\subsection{Significance}

This research contributes to the algorithmic trading community by providing an open-source, documented approach for MT5 data extraction. The methodology enables practitioners to leverage Rust's memory safety, zero-cost abstractions, and concurrent programming capabilities while maintaining connectivity to MT5 market data and order execution facilities. The approach is particularly relevant for developing low-latency trading systems, backtesting frameworks with external data sources, and research tools requiring real-time financial data access.

%% ============================================================================
%% RELATED WORK
%% ============================================================================

\section{Related Work}

\subsection{MetaTrader 5 and MQL5 Ecosystem}

MetaTrader 5 represents MetaQuotes Software Corp.'s flagship trading platform, succeeding MetaTrader 4 with enhanced multi-asset capabilities, an improved strategy testing environment, and the MQL5 programming language \cite{metaquotes2024}. The MQL5 language provides comprehensive APIs for market data access, order management, technical indicator development, and graphical user interface construction within the MT5 terminal. However, MQL5's execution remains confined to the MT5 runtime environment, limiting integration with external systems and modern development ecosystems.

The official MetaTrader 5 Python package, introduced by MetaQuotes, enables Python scripts to connect to running MT5 terminals for data retrieval and order submission \cite{metaquotes_python2024}. While this integration expanded MT5's accessibility to the Python data science ecosystem, the package operates through an inter-process communication mechanism that introduces latency and does not support real-time tick streaming with microsecond-level timestamps.

\subsection{ZeroMQ for Financial Applications}

ZeroMQ (Ã˜MQ) is a high-performance asynchronous messaging library designed for building scalable distributed systems \cite{hintjens2013}. Unlike traditional message brokers, ZeroMQ operates as a lightweight embedded messaging layer without requiring centralized infrastructure. The library provides multiple messaging patterns including publish--subscribe (PUB/SUB) for one-to-many data distribution and request--reply (REQ/REP) for synchronous communication \cite{hintjens2013}.

ZeroMQ has been adopted in financial technology applications due to its low-latency characteristics, language-agnostic design, and support for various transport protocols including TCP and inter-process communication (IPC) \cite{arndt2019}. Prior work has demonstrated ZeroMQ integration with trading platforms, notably in the context of MT4 and Python bridges, though comprehensive documentation for MT5 integration with systems programming languages remains sparse \cite{darwinex2020}.

\subsection{Rust for Systems Programming}

Rust has emerged as a compelling language for systems programming applications requiring both performance and safety guarantees \cite{matsakis2014}. The language's ownership system provides compile-time guarantees against memory safety violations, data races, and null pointer dereferences---common sources of bugs in C and C++ codebases. Rust's zero-cost abstractions enable high-level programming constructs without runtime performance penalties, making it suitable for latency-sensitive applications \cite{jung2017}.

In financial technology, Rust adoption has accelerated for developing trading systems, market data handlers, and risk management components where reliability and performance are paramount \cite{rust_finance2022}. The language's async/await concurrency model, enabled by the Tokio runtime, provides efficient handling of concurrent I/O operations essential for real-time data streaming applications \cite{tokio2023}.

\subsection{Inter-Process Communication in Trading Systems}

Trading system architectures frequently employ inter-process communication (IPC) mechanisms to connect components developed in different languages or running in separate processes \cite{harris2003}. Common approaches include shared memory for ultra-low-latency communication, TCP/IP sockets for networked components, and message queuing systems for decoupled architectures. The choice of IPC mechanism involves trade-offs between latency, throughput, reliability, and development complexity \cite{arndt2019}.

ZeroMQ's socket abstraction provides a middle ground, offering lower latency than traditional message brokers while maintaining the flexibility of language-agnostic message passing. The library's support for multiple messaging patterns enables system designers to select appropriate communication semantics for different data flows within trading architectures.

%% ============================================================================
%% METHODOLOGY
%% ============================================================================

\section{Methodology}

\subsection{System Architecture}

The proposed SUM3API system implements a dual-socket ZeroMQ architecture connecting the MetaTrader 5 trading platform with a Rust-based trading terminal application. The architecture employs two distinct communication channels optimized for their respective data flow patterns:

\begin{enumerate}
    \item \textbf{Tick Data Channel (PUB/SUB)}: A publish--subscribe socket pair operating on TCP port 5555 for one-way streaming of tick data, account information, and position/order state from MT5 to the Rust application.
    \item \textbf{Order Execution Channel (REQ/REP)}: A request--reply socket pair on TCP port 5556 for bidirectional command execution including trade orders, position management, and historical data requests.
\end{enumerate}

This separation of concerns aligns messaging patterns with data characteristics: high-frequency, unidirectional tick data employs the fire-and-forget semantics of PUB/SUB, while order execution requiring acknowledgment uses synchronous REQ/REP communication.

\subsection{MQL5 Component Design}

The MQL5 component consists of two primary artifacts:

\subsubsection{ZeroMQ Wrapper Class (Zmq.mqh)}

A lightweight wrapper class encapsulating ZeroMQ native library calls. The \texttt{CZmq} class manages socket lifecycle, connection establishment, and message transmission through the following interface:

\begin{lstlisting}[language=C++, caption=CZmq Class Interface]
class CZmq {
private:
   long m_context;
   long m_socket;
   bool m_initialized;
public:
   bool Init(int type);
   bool Bind(string endpoint);
   bool Connect(string endpoint);
   int Send(string message, bool nonBlocking);
   string Receive(bool nonBlocking);
   void Shutdown();
};
\end{lstlisting}

The wrapper imports functions from \texttt{libzmq.dll} using MQL5's native DLL import mechanism, exposing context creation (\texttt{zmq\_ctx\_new}), socket operations (\texttt{zmq\_socket}, \texttt{zmq\_bind}, \texttt{zmq\_connect}), and message transmission (\texttt{zmq\_send}, \texttt{zmq\_recv}).

\subsubsection{Expert Advisor (ZmqPublisher.mq5)}

The Expert Advisor executes on an MT5 chart and performs continuous data extraction and command processing:

\begin{itemize}
    \item \textbf{OnInit()}: Initializes ZeroMQ context and binds PUB socket (port 5555) and REP socket (port 5556)
    \item \textbf{OnTick()}: On each market tick, gathers current bid/ask prices, account state, open positions, and pending orders; serializes data to JSON; publishes to PUB socket; non-blocking check for incoming REQ messages
    \item \textbf{OnDeinit()}: Graceful shutdown of ZeroMQ sockets and context
\end{itemize}

\subsection{Rust Application Architecture}

The Rust application employs an asynchronous architecture built on the Tokio runtime, organizing functionality into three concurrent tasks:

\subsubsection{Tick Subscriber Task}

A dedicated async task connects to the MT5 PUB socket and continuously receives tick data:

\begin{lstlisting}[language=Rust, caption=Tick Subscriber Pattern]
let mut socket = zeromq::SubSocket::new();
socket.connect("tcp://127.0.0.1:5555").await?;
socket.subscribe("").await?;

loop {
    match socket.recv().await {
        Ok(msg) => {
            let tick: TickData = 
                serde_json::from_slice(&msg)?;
            tick_tx.send(tick).await?;
        }
        Err(e) => handle_error(e),
    }
}
\end{lstlisting}

\subsubsection{Order Handler Task}

A second async task manages the REQ socket for order execution:

\begin{lstlisting}[language=Rust, caption=Order Handler Pattern]
let mut socket = zeromq::ReqSocket::new();
socket.connect("tcp://127.0.0.1:5556").await?;

while let Some(request) = order_rx.recv().await {
    let json = serde_json::to_string(&request)?;
    socket.send(json.into()).await?;
    let response = socket.recv().await?;
    response_tx.send(parse_response(response)?).await?;
}
\end{lstlisting}

\subsubsection{GUI Task}

The main application thread runs an \texttt{egui}-based graphical interface, consuming tick data via MPSC channels and rendering real-time price charts, account information, and trade controls.

\subsection{Data Serialization}

All inter-process communication employs JSON serialization for message payloads. While JSON introduces serialization overhead compared to binary formats, it provides debugging transparency and simplifies cross-language compatibility. The tick data message structure includes the following example:

\begin{lstlisting}[caption=Tick Data JSON Structure]
{
    "symbol": "XAUUSD",    
    "bid": 2650.55,
    "ask": 2650.75,
    "time": 1706284800,
    "volume": 100,
    "balance": 10000.00,
    "equity": 10150.25,
    "margin": 500.00,
    "free_margin": 9650.25,
    "min_lot": 0.01,
    "max_lot": 100.00,
    "lot_step": 0.01,
    "positions": [...],
    "orders": [...]
}
\end{lstlisting}

All metadata are fetched automatically, independent of the ticker or symbol attached to the files.

%% ============================================================================
%% IMPLEMENTATION
%% ============================================================================

\section{Implementation}

\subsection{MQL5 Implementation Details}

The MQL5 implementation totals approximately 600 lines of code across four files: the \texttt{Zmq.mqh} wrapper (144 lines),  the \texttt{ZmqPublisher.mq5} Expert Advisor (451), and the the \texttt{libsodium.dll \& libzmq.dll} DLLs files.

\subsubsection{ZeroMQ Library Integration}

The native ZeroMQ library (\texttt{libzmq.dll}) is integrated through MQL5's \texttt{\#import} directive, which enables calling external DLL functions. The wrapper handles 64-bit pointer compatibility by using \texttt{long} type for context and socket handles:

\begin{lstlisting}[language=C++, caption=DLL Import Declarations]
#import "libzmq.dll"
   long zmq_ctx_new();
   int zmq_ctx_term(long context);
   long zmq_socket(long context, int type);
   int zmq_close(long socket);
   int zmq_bind(long socket, uchar &endpoint[]);
   int zmq_send(long socket, uchar &buf[], 
                int len, int flags);
   int zmq_recv(long socket, uchar &buf[], 
                int len, int flags);
#import
\end{lstlisting}

\subsubsection{Tick Publishing}

The \texttt{OnTick()} handler constructs a comprehensive JSON message on each market tick. Position and order data are aggregated from MT5's trading API functions (\texttt{PositionsTotal()}, \texttt{PositionGetSymbol()}, etc.) and serialized into the message payload. Non-blocking send semantics ensure the Expert Advisor does not stall on network I/O.

\subsubsection{Order Processing}

Incoming order requests are processed via non-blocking receive on the REP socket. The Expert Advisor parses the JSON request, executes the appropriate trading operation using MT5's \texttt{OrderSend()} function, and returns a JSON response indicating success or failure with error details.

\subsection{Rust Implementation Details}

The Rust application (\texttt{main.rs}) comprises 853 lines of code with the following dependencies (from \texttt{Cargo.toml}):

\begin{table}[H]
\centering
\caption{Rust Dependencies}
\label{tab:dependencies}
\begin{tabular}{ll}
\toprule
\textbf{Crate} & \textbf{Purpose} \\
\midrule
eframe 0.27.1 & Native application framework \\
egui 0.27.1 & Immediate-mode GUI library \\
egui\_plot 0.27.1 & Chart visualization \\
zeromq 0.5.0-pre & ZeroMQ bindings (async) \\
serde 1.0.197 & Serialization framework \\
serde\_json 1.0.114 & JSON serialization \\
tokio 1.36.0 & Async runtime \\
chrono 0.4.43 & Date/time handling \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Data Structures}

The application defines strongly-typed structures for all message formats, leveraging Serde's derive macros for automatic JSON serialization:

\begin{lstlisting}[language=Rust, caption=Core Data Structures]
#[derive(Clone, Debug, Deserialize)]
struct TickData {
    symbol: String,
    bid: f64,
    ask: f64,
    time: i64,
    volume: u64,
    balance: f64,
    equity: f64,
    margin: f64,
    free_margin: f64,
    positions: Vec<PositionData>,
    orders: Vec<PendingOrderData>,
}
\end{lstlisting}

\subsubsection{Asynchronous Channel Architecture}

The application employs Tokio's MPSC channels for thread-safe communication between async tasks and the GUI:

\begin{itemize}
    \item \texttt{tick\_channel}: Buffer capacity 100, carries \texttt{TickData} from subscriber to GUI
    \item \texttt{order\_channel}: Buffer capacity 10, carries \texttt{OrderRequest} from GUI to handler
    \item \texttt{response\_channel}: Buffer capacity 10, carries \texttt{OrderResponse} from handler to GUI
\end{itemize}

\subsubsection{GUI Implementation}

The trading interface is built using egui's immediate-mode paradigm, providing:

\begin{itemize}
    \item Real-time bid/ask price chart with configurable display window
    \item Account information panel (balance, equity, margin)
    \item Trade execution controls (market, limit, stop orders)
    \item Position and order management with close/cancel functionality
    \item Historical data download interface (OHLC and tick data)
    \item Live tick recording to CSV
    \item Messages and notifications for recent calls
\end{itemize}

\subsection{Feature Summary}

Table~\ref{tab:features} summarizes the complete feature set of the implemented system.

\begin{table}[H]
\centering
\caption{System Feature Summary}
\label{tab:features}
\begin{tabular}{p{3cm}p{5cm}}
\toprule
\textbf{Feature} & \textbf{Description} \\
\midrule
Live Tick Streaming & Real-time bid/ask data at tick-level granularity with timestamp \\
Account Monitoring & Balance, equity, margin, free margin updated on each tick \\
Trade Execution & Market buy/sell, limit orders, stop orders with configurable lot size \\
Position Management & View active positions with real-time P\&L; close positions \\
Order Management & View pending limit/stop orders; cancel orders \\
Historical Data & Download OHLC bars or raw tick data as CSV files \\
Live Recording & Record incoming tick stream to timestamped CSV files \\
Chart Visualization & Bid/ask lines, position price levels, order execution markers \\
Messages & Notifications for debugging and recent calls \\
\bottomrule
\end{tabular}
\end{table}

%% ============================================================================
%% BENCHMARK AND RESULTS
%% ============================================================================

\section{Benchmark Methodology and Results}

\subsection{Benchmark Design}

The validation methodology focuses on demonstrating functional correctness and characterizing system performance through the following approaches:

\subsubsection{Functional Validation}

The system was validated through integration testing within a live MT5 environment connected to a Standard-cent live trading account from Exness Broker. Validation criteria included:

\begin{itemize}
    \item Successful connection establishment between MQL5 and Rust components
    \item Accurate tick data transmission with no message loss under normal market conditions
    \item Correct order execution and response handling
    \item Proper position and order state synchronization
    \item CSV export functionality verification
\end{itemize}

\subsubsection{Latency Characterization}

End-to-end latency was characterized by measuring the time delta between tick generation in MT5 and reception in the Rust application. Due to the asynchronous nature of ZeroMQ PUB/SUB, latency measurements capture the combined overhead of:

\begin{enumerate}
    \item JSON serialization in MQL5
    \item ZeroMQ message transmission
    \item TCP/IP network stack processing (localhost)
    \item ZeroMQ message reception
    \item JSON deserialization in Rust
    \item Channel transmission to GUI thread
\end{enumerate}

\subsubsection{Throughput Assessment}

Message throughput was assessed under varying market activity conditions, from low-volatility periods with sparse tick arrivals to high-volatility sessions with rapid tick sequences.

\subsection{Results}

\subsubsection{Functional Validation Results}

The implemented system successfully demonstrated all specified features:

\begin{itemize}
    \item \textbf{Connection}: Both PUB/SUB and REQ/REP socket pairs established reliably
    \item \textbf{Tick Streaming}: Continuous real-time updates with visual confirmation via the price chart
    \item \textbf{Order Execution}: Market orders executed with correct lot sizing; limit and stop orders placed successfully
    \item \textbf{Position Sync}: Active positions displayed with updating profit/loss figures
    \item \textbf{Historical Export}: OHLC and tick data exported to properly formatted CSV files
\end{itemize}

\subsubsection{Performance Characteristics}

Table~\ref{tab:performance} presents observed performance characteristics during testing.

\begin{table}[H]
\centering
\caption{Performance Characteristics}
\label{tab:performance}
\begin{tabular}{ll}
\toprule
\textbf{Metric} & \textbf{Observed Value} \\
\midrule
Tick-to-Display Latency & Sub-millisecond (localhost) \\
Message Throughput & Sufficient for retail tick rates \\
Memory Footprint (Rust) & ~50--100 MB typical \\
CPU Utilization & Minimal during idle; responsive under load \\
Chart Update Rate & 60 FPS continuous repaint \\
Data Buffer & 2000 tick rolling window \\
\bottomrule
\end{tabular}
\end{table}

\subsubsection{Comparison with Native Approaches}

Compared to developing a trading interface purely in MQL5, the proposed methodology offers several advantages:

\begin{itemize}
    \item \textbf{Language Flexibility}: Enables development in Rust with its safety guarantees and ecosystem
    \item \textbf{Extensibility}: External applications can connect to the same ZeroMQ endpoints
    \item \textbf{Modern GUI}: egui provides a more capable UI framework than MQL5's native graphics
    \item \textbf{Data Export}: Straightforward CSV export for external analysis
\end{itemize}

Trade-offs include the complexity of managing two codebases (MQL5 + Rust) and the serialization overhead of JSON messaging.

%% ============================================================================
%% DISCUSSION
%% ============================================================================

\section{Discussion}

\subsection{Validation Through Demonstration}

The functional trading terminal serves as practical validation of the proposed methodology. By implementing a complete set of trading features---from real-time data visualization to order execution---the demonstration establishes that ZeroMQ provides a viable communication layer between MT5 and external Rust applications. The system's successful operation during live market sessions confirms the approach's robustness under realistic conditions.

\subsection{Advantages of the Proposed Approach}

The SUM3API methodology offers several advantages over existing alternatives:

\begin{enumerate}
    \item \textbf{Language Independence}: While this implementation uses Rust, the ZeroMQ-based architecture supports any language with ZeroMQ bindings, including Python, C++, Java, and Go.
    \item \textbf{Real-Time Streaming}: The PUB/SUB pattern enables true real-time tick streaming, unlike polling-based approaches.
    \item \textbf{Bidirectional Communication}: The dual-socket design supports both data receiving and command sending.
    \item \textbf{Decoupled Architecture}: The Rust application operates independently of MT5's internal processes, enabling separate deployment and scaling.
    \item \textbf{Open-Source Availability}: Complete source code availability enables community review, contribution, and adaptation.
\end{enumerate}

\subsection{Limitations}

Several limitations should be acknowledged:

\begin{enumerate}
    \item \textbf{Platform Dependency}: The MQL5 component requires a running MT5 instance, inheriting MT5's platform constraints.
    \item \textbf{Single Symbol Scope}: The current implementation operates on the chart symbol where the EA is attached; multi-symbol support would require architecture extensions.
    \item \textbf{JSON Overhead}: Binary serialization formats (e.g., MessagePack, Protocol Buffers) could reduce serialization latency.
    \item \textbf{Local Communication}: The implementation is optimized for localhost communication; network deployment would require additional security considerations.
    \item \textbf{Error Recovery}: Reconnection logic is basic; production deployments would benefit from enhanced fault tolerance.
\end{enumerate}

\subsection{Practical Applications}

The methodology enables several practical applications:

\begin{itemize}
    \item \textbf{Custom Trading Terminals}: Develop trading interfaces tailored to specific workflows
    \item \textbf{Machine Learning Pipelines}: Stream MT5 data to feature engineering and model inference components
    \item \textbf{Research Tools}: Export historical and live data for quantitative analysis
    \item \textbf{Multi-Platform Strategies}: Execute strategy logic in Rust while using MT5 for market access
    \item \textbf{Monitoring Dashboards}: Build custom visualization and alerting systems
\end{itemize}

%% ============================================================================
%% CONCLUSION
%% ============================================================================

\section{Conclusion}

\subsection{Summary of Contributions}

This research presented SUM3API, a methodology for establishing bidirectional real-time communication between MetaTrader 5 and Rust applications using ZeroMQ messaging. The key contributions include:

\begin{enumerate}
    \item A reusable MQL5 ZeroMQ wrapper class (\texttt{CZmq}) for socket operations
    \item An Expert Advisor design pattern for tick streaming and command processing
    \item A complete Rust application architecture demonstrating async data handling and GUI integration
    \item Open-source implementation enabling reproducibility and extension
\end{enumerate}

The methodology addresses the gap in documented approaches for MT5 data extraction to external high-performance applications, enabling quantitative researchers and algorithmic traders to leverage modern programming tools while maintaining connectivity to MT5's market access infrastructure.

\subsection{Open-Source Availability}

All source code, raw \& final documentation, video demonstrations, and examples are available under an open-source license at:

\begin{center}
\url{https://github.com/algorembrant/SUM3API}
\end{center}

\subsection{Future Work}

Future development directions include:

\begin{itemize}
    \item Multi-symbol support through symbol-keyed message routing
    \item Binary serialization for reduced latency
    \item Enhanced fault tolerance with automatic reconnection
    \item Strategy execution framework built on the communication layer
    \item Performance benchmarking with microsecond-precision instrumentation
    \item Docker containerization for simplified deployment
\end{itemize}

%% ============================================================================
%% ACKNOWLEDGMENTS
%% ============================================================================

\section*{Acknowledgments}

The author acknowledges the ZeroMQ community for providing the robust messaging library that forms the foundation of this work, and the Rust community for the excellent async ecosystem enabling this implementation.

%% ============================================================================
%% REFERENCES
%% ============================================================================

\bibliographystyle{IEEEtran}
\bibliography{references}

\end{document}
